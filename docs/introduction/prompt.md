# 提示工程 Prompt Engineering

本小节会讲解如何进行有效的 Prompt Engineering，并在后续章节中提供 Task 1-4 的 Prompt Example。

## 简介

**提示工程（Prompt Engineering）** 是一门新兴学科，专注于提示词的设计、开发与优化，旨在帮助用户更有效地将大语言模型（Large Language Model, LLM）应用于各种场景和研究领域。掌握提示工程的相关技能，不仅有助于我们深入理解大型语言模型的能力边界，还能更好地利用其潜力。

提示工程不仅仅局限于提示词的设计与研发，它还涵盖了与大语言模型交互和开发的多种技能与技术。提示工程在实现与大语言模型的高效交互、对接以及理解其能力方面发挥着关键作用。通过提示工程，用户不仅可以提升大语言模型的安全性，还能通过引入专业领域知识和外部工具，进一步增强大语言模型的能力。

在编译原理课程中，同学们可以设计高效且精准的提示技术，以提升大语言模型在问题答疑、代码分析、语法解析等方面的表现。通过提示工程的优化，大语言模型能够更好地服务于教学与学习需求，助力课程目标的实现。

**【强烈推荐学习】**[提示工程指南 | Prompt Engineering Guide](https://www.promptingguide.ai/zh)

## 提示词要素

**指令**：想要模型执行的特定任务或指令。

**上下文**：包含外部信息或额外的上下文信息，引导语言模型更好地响应。

**输入数据**：用户输入的内容或问题。

**输出指示**：指定输出的类型或格式。

## 通用技巧

### **从简单开始**

- 提示设计是一个需要反复实验的迭代过程。

- 可以从简单提示开始，逐步添加元素和上下文以优化结果。

### **具体性**

- 提示需详细且具描述性，具体说明任务和期望结果（包括风格或格式）。

- 提供示例有助于模型输出符合特定格式的结果。

- 注意提示长度限制，避免无关细节，保持相关性。

### **分解任务**

- 将复杂任务拆分为简单子任务，逐步构建，避免一开始过于复杂。

## 相关例子

### 代码改写

假设你在实现一个简单的词法分析器，但代码效率较低或风格不符合要求，你可以要求大模型改写代码。

````markdown
我有一个用 C 语言写的词法分析器片段，功能是识别小写字母作为标识符（ID）、数字作为数字（NUM），但存在以下问题：
1）使用 getchar() 逐字符读取性能低；
2）仅识别单个字符（如输入‘abc’输出‘ID: a’‘ID: b’‘ID: c’，而期望‘ID: abc’作为单个标识符）；
3）代码逻辑都在 main 中，缺乏模块化。
我希望你优化这段代码的性能（例如减少输入读取开销并支持多字符标识符和数字），并改写成逻辑清晰、结构简洁的版本。以下是原始代码：

```cpp
#include <stdio.h>
int main() {
    char c;
    while ((c = getchar()) != EOF) {
        if (c >= 'a' && c <= 'z') {
            printf("ID: %c\n", c);
        } else if (c >= '0' && c <= '9') {
            printf("NUM: %c\n", c);
        }
    }
}
```

请输出优化后的完整 C 代码，包含以下要求：
1）添加详细注释，说明每个主要改动的原因和效果（如性能提升或功能增强）；
2）确保代码可运行并支持多字符 token（如‘abc’输出‘ID: abc’，‘123’输出‘NUM: 123’）；
3）如果可能，简要说明性能改进的原理。
````

### 代码解释

你有一个用 C 实现的 First 集合计算代码，但不理解其逻辑。

````markdown
我有一个用 C 实现的 First 集合计算代码，用于 LL(1) 分析表构建。代码从产生式数组（如‘S=aA’表示 S -> aA，其中位置 0 为左部符号，位置 2 为右部首字符）中计算某个非终结符的 First 集合，但仅处理右部首字符为小写字母（终结符）的情况。例如，输入产生式 {‘S=aA’, ‘A=b’}，调用 first(‘S’, ...) 输出‘First(S) = a’。
我希望你逐行解释这段代码的实现逻辑（包括每个变量的作用和代码步骤的目的），并详细说明 First 集合在 LL(1) 编译器语法分析中的具体作用及其局限性。以下是代码：

```cpp
#include <stdio.h>
#define MAX_PROD 10

void first(char symbol, char productions[MAX_PROD][10], int n, char *result) {
    int i, j = 0;
    for (i = 0; i < n; i++) {
        if (productions[i][0] == symbol) {
            if (productions[i][2] >= 'a' && productions[i][2] <= 'z') {
                result[j++] = productions[i][2];
            }
        }
    }
    result[j] = '\0';
}

int main() {
    char productions[MAX_PROD][10] = {"S=aA", "A=b"};
    char result[10];
    first('S', productions, 2, result);
    printf("First(S) = %s\n", result);
    return 0;
}
```

请以代码块加文字说明的形式逐行解释代码，并以单独段落详细说明 First 集合在 LL(1) 分析表构建中的作用（包括如何用于预测分析）及其局限性。输出应包含：
1）代码的完整逐行分析；
2）First 集合的编译器作用说明；
3）代码当前的限制或潜在改进建议。
````

### 代码生成

````markdown
我需要为编译原理实验生成一个递归下降解析器。文法如下，其中‘E’是起始符号，‘id’表示单个小写字母标识符（如‘a’到‘z’），‘+’和‘_’是运算符，‘(’和‘)’是括号，‘ε’表示空串。输入为字符串（如‘a + b _ c’或‘(a + b)’），期望解析成功时输出成功消息，失败时报告错误。我希望你用 C 语言为以下文法生成一个完整的递归下降解析器程序，能够解析符合该文法的表达式并验证其语法正确性。文法如下：

```text
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id
```

请输出完整的 C 语言代码，包含以下要求：
1）实现递归下降解析器，能够解析输入字符串并验证文法；
2）包含错误处理机制，提示非法字符或语法错误（如缺少括号）；
3）为每个函数添加注释，说明其功能和对应的文法规则；
4）包含 main 函数，提供输入输出示例（如成功时输出‘Parsing successful’，失败时输出错误信息，例如‘Error at position X: message’）。
````

### 结构化输出

````text
我正在进行编译原理实验，需要为一个简单的词法分析器设计一个 C++ 程序，用于从输入字符流中识别 token。输入是一串字符（例如‘if x123 456’），其中包含以下 token 类型：
1）关键字：仅支持‘if’和‘while’；
2）标识符：由小写字母组成（如‘x123’、‘abc’）；
3）数字：由数字组成（如‘456’、‘123’）。

我的目标是用 C++ 实现一个完整的词法分析器程序，能够分解输入字符串并分类输出每个 token 的类型和值。我希望你扮演编译原理专家，生成一个完整的 C++ 程序，满足以下要求：
1）使用 C++ 类和结构体设计，例如定义一个 Token 结构体存储 token 类型和值；
2）包含词法分析逻辑，能够正确识别关键字、标识符和数字；
3）实现错误处理机制，提示非法字符（如‘@’或‘#’）；
4）为每个主要部分添加注释，说明其功能和识别规则。

请以 C++ 代码格式输出完整的程序，将代码置于 ```cpp``` 代码块中，确保代码结构清晰、可编译运行，并在 main 函数中处理输入示例（如‘if x123 456’），输出每个 token 的类型和值（例如‘Keyword: if’, ‘Identifier: x123’, ‘Number: 456’）。输出应包含完整的 C++ 源代码，带有头文件、类定义和实现逻辑。
````

## 角色扮演（自定义人设）

扮演软件工程师

```text
你是一位技术高超的软件工程师，名叫 Roo，拥有深厚的编程经验和广泛的知识体系，精通多种编程语言（如 C、Python、Java 等）、主流框架（如 Spring、React、Django 等）、设计模式（如单例、工厂、观察者模式等）以及软件开发的最佳实践（如代码可读性、性能优化、测试驱动开发）。你擅长分析复杂的代码问题，提供清晰且高效的解决方案，并能根据用户的需求生成高质量的代码、解释技术细节或优化现有实现。作为一名虚拟助手，你的目标是通过逻辑严谨的推理和结构化的回答，帮助用户解决软件开发中的实际问题，同时展现对现代工程实践的深刻理解。你还能根据 Prompt 的具体上下文，灵活调整回答的深度和形式（例如代码示例、逐步分析、表格对比等），确保输出既实用又易于理解。
```

扮演编译原理专家

```markdown
你是一个编译原理领域的专家，旨在为用户提供准确、高效且深入的技术支持。你的核心任务是协助用户理解和解决与编译器设计、实现及相关理论的问题。你的专业领域包括但不限于：

- 词法分析（Lexical Analysis）
- 语法分析（Syntax Analysis，包括上下文无关文法、LR、LL 解析等）
- 语义分析（Semantic Analysis）
- 中间代码生成（Intermediate Code Generation）
- 代码优化（Code Optimization）
- 目标代码生成（Target Code Generation）
- 符号表管理、错误处理等编译器相关技术

**行为准则：**

- 提供清晰、结构化的回答，必要时包含伪代码、示例或数学推导。
- 如果问题涉及具体编程语言（如 C、Java 或 Python），根据上下文假设用户意图，并给出语言相关的实现建议。
- 当用户问题不够明确时，主动提出澄清问题以确保回答准确性。
- 避免无关的冗长解释，保持回答简洁且专业。

**工具与限制：**

- 你可以分析用户上传的代码片段、语法规则或相关文档（如 PDF 或文本文件），并给出具体建议。
- 如果用户询问与编译原理无关的内容，礼貌地引导他们回到主题。

**语气与风格：**

- 使用专业但友好的语气，类似一位耐心且经验丰富的导师。
- 根据用户的技术水平调整回答的深度（从入门到高级），默认假设用户有一定编程或计算机科学基础。
```

## 参考

[提示工程指南 | Prompt Engineering Guide](https://www.promptingguide.ai/zh)

[Prompt Library | DeepSeek API Docs](https://api-docs.deepseek.com/zh-cn/prompt-library/?utm_source=ai-bot.cn)

## Task 1-4 Prompt Examples 链接

在每一章的 Prompt 示例小节都给出了 prompt 示例，大家可以选择性使用或优化这些 prompt。

- [Task1 Prompt Example](task1_doc/prompt.md#task1-prompt-example)

- [Task2 Prompt Example](task2_doc/prompt.md#task2-prompt-example)

- [Task3 Prompt Example](task3_doc/prompt.md#task3-prompt-example)

- [Task4 Prompt Example](task4_doc/prompt.md#task4-prompt-example)
